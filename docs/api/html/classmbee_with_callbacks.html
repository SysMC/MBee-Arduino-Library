<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Класс mbeeWithCallbacks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MBee.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Классы</a> &#124;
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="classmbee_with_callbacks-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle">
<div class="title">Класс mbeeWithCallbacks</div>  </div>
</div><!--header-->
<div class="contents">

<p>Этот класс может быть использован вместо класса <a class="el" href="class_m_bee.html" title="Основной интерфейс для связи с радиомодулями MBee всех серий. ">MBee</a> и позволяет самостоятельно создавать функции, которые будут автоматически вызываться при получении пакетов от радиомодуля.  
 <a href="classmbee_with_callbacks.html#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="_m_bee_8h_source.html">MBee.h</a>&gt;</code></p>
<div class="dynheader">
Граф наследования:mbeeWithCallbacks:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmbee_with_callbacks.png" usemap="#mbeeWithCallbacks_map" alt=""/>
  <map id="mbeeWithCallbacks_map" name="mbeeWithCallbacks_map">
<area href="class_m_bee.html" title="Основной интерфейс для связи с радиомодулями MBee всех серий. " alt="MBee" shape="rect" coords="0,0,121,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:ae70f620ea276cdb9d815b3977910a3dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbee_with_callbacks.html#ae70f620ea276cdb9d815b3977910a3dd">onPacketError</a> (void(*func)(uint8_t, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="memdesc:ae70f620ea276cdb9d815b3977910a3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Регистрация callback-функции для события ошибки чтения пакета.  <a href="#ae70f620ea276cdb9d815b3977910a3dd">Подробнее...</a><br /></td></tr>
<tr class="separator:ae70f620ea276cdb9d815b3977910a3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bc1e5f801d44f2af7d7d665d9884b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbee_with_callbacks.html#a36bc1e5f801d44f2af7d7d665d9884b2">onResponse</a> (void(*func)(XBeeResponse &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="memdesc:a36bc1e5f801d44f2af7d7d665d9884b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Регистрация callback-функции для события приема пакета от модуля.  <a href="#a36bc1e5f801d44f2af7d7d665d9884b2">Подробнее...</a><br /></td></tr>
<tr class="separator:a36bc1e5f801d44f2af7d7d665d9884b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821a5c46153ce7377aecef9a0e924b0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbee_with_callbacks.html#a821a5c46153ce7377aecef9a0e924b0d">onOtherResponse</a> (void(*func)(XBeeResponse &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="memdesc:a821a5c46153ce7377aecef9a0e924b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Регистрация callback-функции для события приема пакета от модуля.  <a href="#a821a5c46153ce7377aecef9a0e924b0d">Подробнее...</a><br /></td></tr>
<tr class="separator:a821a5c46153ce7377aecef9a0e924b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0816a06a407ef2105fdce1151f0a60e0"><td class="memItemLeft" align="right" valign="top"><a id="a0816a06a407ef2105fdce1151f0a60e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onZBTxStatusResponse</b> (void(*func)(ZBTxStatusResponse &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:a0816a06a407ef2105fdce1151f0a60e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861823848d28fd1ee2a72b6fd548ea30"><td class="memItemLeft" align="right" valign="top"><a id="a861823848d28fd1ee2a72b6fd548ea30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onZBRxResponse</b> (void(*func)(ZBRxResponse &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:a861823848d28fd1ee2a72b6fd548ea30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c679061b208127d0deaf454e41530cf"><td class="memItemLeft" align="right" valign="top"><a id="a4c679061b208127d0deaf454e41530cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onZBExplicitRxResponse</b> (void(*func)(ZBExplicitRxResponse &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:a4c679061b208127d0deaf454e41530cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6910c127bddb1ac02f41db3bd9273f4"><td class="memItemLeft" align="right" valign="top"><a id="af6910c127bddb1ac02f41db3bd9273f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onZBRxIoSampleResponse</b> (void(*func)(ZBRxIoSampleResponse &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:af6910c127bddb1ac02f41db3bd9273f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac559d7da19334a73b05c4cfe104034f2"><td class="memItemLeft" align="right" valign="top"><a id="ac559d7da19334a73b05c4cfe104034f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onTxStatusResponse</b> (void(*func)(<a class="el" href="class_tx_status_response.html">TxStatusResponse</a> &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:ac559d7da19334a73b05c4cfe104034f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8391c0e902a1a084cba8567d05b7346"><td class="memItemLeft" align="right" valign="top"><a id="ad8391c0e902a1a084cba8567d05b7346"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onRx16Response</b> (void(*func)(Rx16Response &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:ad8391c0e902a1a084cba8567d05b7346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7745502439e5f262b078416c38103f0"><td class="memItemLeft" align="right" valign="top"><a id="ae7745502439e5f262b078416c38103f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onRx64Response</b> (void(*func)(Rx64Response &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:ae7745502439e5f262b078416c38103f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa462836de782bdfcf33e177a2cb689df"><td class="memItemLeft" align="right" valign="top"><a id="aa462836de782bdfcf33e177a2cb689df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onRx16IoSampleResponse</b> (void(*func)(Rx16IoSampleResponse &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:aa462836de782bdfcf33e177a2cb689df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23488fcc83fc2d7ac078d5d4d69f21b1"><td class="memItemLeft" align="right" valign="top"><a id="a23488fcc83fc2d7ac078d5d4d69f21b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onRx64IoSampleResponse</b> (void(*func)(Rx64IoSampleResponse &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:a23488fcc83fc2d7ac078d5d4d69f21b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a3f9b83bf71210e471944366d5ec4c"><td class="memItemLeft" align="right" valign="top"><a id="ac7a3f9b83bf71210e471944366d5ec4c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onModemStatusResponse</b> (void(*func)(<a class="el" href="class_modem_status_response.html">ModemStatusResponse</a> &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:ac7a3f9b83bf71210e471944366d5ec4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefcd43c1e60d04788bd4c6ce8ba65bb"><td class="memItemLeft" align="right" valign="top"><a id="aeefcd43c1e60d04788bd4c6ce8ba65bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onAtCommandResponse</b> (void(*func)(<a class="el" href="class_at_command_response.html">AtCommandResponse</a> &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:aeefcd43c1e60d04788bd4c6ce8ba65bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b819eb047adcd29753e1b96fb15ade"><td class="memItemLeft" align="right" valign="top"><a id="a81b819eb047adcd29753e1b96fb15ade"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onRemoteAtCommandResponse</b> (void(*func)(<a class="el" href="class_remote_at_command_response.html">RemoteAtCommandResponse</a> &amp;, uintptr_t), uintptr_t data=0)</td></tr>
<tr class="separator:a81b819eb047adcd29753e1b96fb15ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed2019f6ccc5412dc5876cfda8388a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbee_with_callbacks.html#a3ed2019f6ccc5412dc5876cfda8388a8">loop</a> ()</td></tr>
<tr class="memdesc:a3ed2019f6ccc5412dc5876cfda8388a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Главный цикл.  <a href="#a3ed2019f6ccc5412dc5876cfda8388a8">Подробнее...</a><br /></td></tr>
<tr class="separator:a3ed2019f6ccc5412dc5876cfda8388a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf5aad1ae37a39ecf904dc4cf3efb48"><td class="memTemplParams" colspan="2">template&lt;typename Response &gt; </td></tr>
<tr class="memitem:afbf5aad1ae37a39ecf904dc4cf3efb48"><td class="memTemplItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmbee_with_callbacks.html#afbf5aad1ae37a39ecf904dc4cf3efb48">waitFor</a> (Response &amp;response, uint16_t timeout, bool(*func)(Response &amp;, uintptr_t)=NULL, uintptr_t data=0, int16_t frameId=-1)</td></tr>
<tr class="memdesc:afbf5aad1ae37a39ecf904dc4cf3efb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a API response of the given type, optionally filtered by the given match function.  <a href="#afbf5aad1ae37a39ecf904dc4cf3efb48">Подробнее...</a><br /></td></tr>
<tr class="separator:afbf5aad1ae37a39ecf904dc4cf3efb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cf8239b2ab8eaff1fd1e1ea44533d2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbee_with_callbacks.html#ab2cf8239b2ab8eaff1fd1e1ea44533d2">sendAndWait</a> (XBeeRequest &amp;request, uint16_t timeout)</td></tr>
<tr class="memdesc:ab2cf8239b2ab8eaff1fd1e1ea44533d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a XBeeRequest (TX packet) out the serial port, and wait for a status response API frame (up until the given timeout).  <a href="#ab2cf8239b2ab8eaff1fd1e1ea44533d2">Подробнее...</a><br /></td></tr>
<tr class="separator:ab2cf8239b2ab8eaff1fd1e1ea44533d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d39cfc4baec25ff77b11c5a180859e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbee_with_callbacks.html#ac4d39cfc4baec25ff77b11c5a180859e">waitForStatus</a> (uint8_t frameId, uint16_t timeout)</td></tr>
<tr class="memdesc:ac4d39cfc4baec25ff77b11c5a180859e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a status API response with the given frameId and return the status from the packet (for ZB_TX_STATUS_RESPONSE, this returns just the delivery status, not the routing status).  <a href="#ac4d39cfc4baec25ff77b11c5a180859e">Подробнее...</a><br /></td></tr>
<tr class="separator:ac4d39cfc4baec25ff77b11c5a180859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_bee"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_bee')"><img src="closed.png" alt="-"/>&#160;Открытые члены унаследованные от <a class="el" href="class_m_bee.html">MBee</a></td></tr>
<tr class="memitem:af8382041415c32bc5c51a0a76e767aca inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#af8382041415c32bc5c51a0a76e767aca">readPacket</a> ()=0</td></tr>
<tr class="memdesc:af8382041415c32bc5c51a0a76e767aca inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Чтение всех байт, имеющихся в приемном буфере UART.  <a href="class_m_bee.html#af8382041415c32bc5c51a0a76e767aca">Подробнее...</a><br /></td></tr>
<tr class="separator:af8382041415c32bc5c51a0a76e767aca inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11895d60d118c9edee825847a1e5b61d inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#a11895d60d118c9edee825847a1e5b61d">readPacket</a> (int timeout)=0</td></tr>
<tr class="memdesc:a11895d60d118c9edee825847a1e5b61d inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ожидает приема пакета от модуля в течение <em>timeout</em> миллисекунд.  <a href="class_m_bee.html#a11895d60d118c9edee825847a1e5b61d">Подробнее...</a><br /></td></tr>
<tr class="separator:a11895d60d118c9edee825847a1e5b61d inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cfd2f62c736a4a79f298e70236bbec inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#a90cfd2f62c736a4a79f298e70236bbec">readPacketUntilAvailable</a> ()=0</td></tr>
<tr class="memdesc:a90cfd2f62c736a4a79f298e70236bbec inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ожидает приема пакета до тех пор, пока он не будет получен или не произойдет какая-либо ошибка.  <a href="class_m_bee.html#a90cfd2f62c736a4a79f298e70236bbec">Подробнее...</a><br /></td></tr>
<tr class="separator:a90cfd2f62c736a4a79f298e70236bbec inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2773c57b5447c92d19269b64557a63f6 inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#a2773c57b5447c92d19269b64557a63f6">send</a> (void *)=0</td></tr>
<tr class="memdesc:a2773c57b5447c92d19269b64557a63f6 inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Передача данных модулю или удаленному узлу.  <a href="class_m_bee.html#a2773c57b5447c92d19269b64557a63f6">Подробнее...</a><br /></td></tr>
<tr class="separator:a2773c57b5447c92d19269b64557a63f6 inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a6c9a0bd0ceb46e83a32bfac9dd79d inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top"><a id="ae7a6c9a0bd0ceb46e83a32bfac9dd79d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#ae7a6c9a0bd0ceb46e83a32bfac9dd79d">begin</a> (Stream &amp;serial)</td></tr>
<tr class="memdesc:ae7a6c9a0bd0ceb46e83a32bfac9dd79d inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Инициализирует соединение с радиомодулем на заданном COM-порте. <br /></td></tr>
<tr class="separator:ae7a6c9a0bd0ceb46e83a32bfac9dd79d inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380be1430c9b264329a0465db3f7a0f1 inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#a380be1430c9b264329a0465db3f7a0f1">setSerial</a> (Stream &amp;serial)</td></tr>
<tr class="memdesc:a380be1430c9b264329a0465db3f7a0f1 inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Назначает последовательный порт.  <a href="class_m_bee.html#a380be1430c9b264329a0465db3f7a0f1">Подробнее...</a><br /></td></tr>
<tr class="separator:a380be1430c9b264329a0465db3f7a0f1 inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a3b31518f8422ba462befac4bef9dc inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top"><a id="a48a3b31518f8422ba462befac4bef9dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#a48a3b31518f8422ba462befac4bef9dc">available</a> ()</td></tr>
<tr class="memdesc:a48a3b31518f8422ba462befac4bef9dc inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверяет наличие принятых данных в буфере UART. <br /></td></tr>
<tr class="separator:a48a3b31518f8422ba462befac4bef9dc inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6c7407cf417e74f6759d9aae28bae5 inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top"><a id="a6a6c7407cf417e74f6759d9aae28bae5"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#a6a6c7407cf417e74f6759d9aae28bae5">read</a> ()</td></tr>
<tr class="memdesc:a6a6c7407cf417e74f6759d9aae28bae5 inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Считывает 1 байт из входного буфера UART. <br /></td></tr>
<tr class="separator:a6a6c7407cf417e74f6759d9aae28bae5 inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0e09cde51b5686fdf961c9b01e5fb8 inherit pub_methods_class_m_bee"><td class="memItemLeft" align="right" valign="top"><a id="a3d0e09cde51b5686fdf961c9b01e5fb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_bee.html#a3d0e09cde51b5686fdf961c9b01e5fb8">write</a> (uint8_t val)</td></tr>
<tr class="memdesc:a3d0e09cde51b5686fdf961c9b01e5fb8 inherit pub_methods_class_m_bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Передает 1 байт по UART. <br /></td></tr>
<tr class="separator:a3d0e09cde51b5686fdf961c9b01e5fb8 inherit pub_methods_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Дополнительные унаследованные члены</h2></td></tr>
<tr class="inherit_header pub_attribs_class_m_bee"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_m_bee')"><img src="closed.png" alt="-"/>&#160;Открытые атрибуты унаследованные от <a class="el" href="class_m_bee.html">MBee</a></td></tr>
<tr class="memitem:a5dbd5beb4a144b0f6242e5befff3b880 inherit pub_attribs_class_m_bee"><td class="memItemLeft" align="right" valign="top"><a id="a5dbd5beb4a144b0f6242e5befff3b880"></a>
Stream *&#160;</td><td class="memItemRight" valign="bottom"><b>_serial</b></td></tr>
<tr class="separator:a5dbd5beb4a144b0f6242e5befff3b880 inherit pub_attribs_class_m_bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><p>Этот класс может быть использован вместо класса <a class="el" href="class_m_bee.html" title="Основной интерфейс для связи с радиомодулями MBee всех серий. ">MBee</a> и позволяет самостоятельно создавать функции, которые будут автоматически вызываться при получении пакетов от радиомодуля. </p>
<p>Такой подход значительно упрощает процесс программирования. При использовании этого класса, прежде всего необходимо зарегистрировать свою callback функцию, с помощью метода onXxx. Каждый метод имеет аргумент uintptr_t, который может быть использован для передачи произвольных данных в callback-функцию. Такой подход является полезным при регистрации одной и той же callback-функции для нескольких событий, либо в случае, если функция должна выполнять разные действия в разных обстоятельствах. Обработка этих данных внутри функции является опциональной, однако присутствие их в списке аргументов callback-функции является обязательным. Если их обработка не предполагается, то данные можно просто проигнорировать. Тип uintptr_t является целым. Размер его должен быть достаточен для хранения указателя, характерного для данной платформы Arduino. Например, его длина для плат, использующих AVR, должна быть не менее 16 бит, а для устройств на основе ARM - не менее 32. Для каждого события может быть зарегистрирована только одна функция. Таким образом, повторная регистрации функции для одного и того же события перепишет ранее зарегистрированную. Для отмены регистрации callback-функции, необходимо передать ей NULL вкачестве аргумента. Для того, чтобы callback-функции работали, необходимо регулярно вызывать метод этого класса <a class="el" href="classmbee_with_callbacks.html#a3ed2019f6ccc5412dc5876cfda8388a8" title="Главный цикл. ">loop()</a>. Проще всего поместить вызов этого метода в главный цикл скетча - loop{}. Этот метод автоматически вызывает функции <a class="el" href="class_m_bee.html#af8382041415c32bc5c51a0a76e767aca" title="Чтение всех байт, имеющихся в приемном буфере UART. ">readPacket()</a> и getResponse() и некторых других из класса <a class="el" href="class_m_bee.html" title="Основной интерфейс для связи с радиомодулями MBee всех серий. ">MBee</a>. Таким образом, вызывать их непосредственно из скетча не требуется (хотя, если это сделать то ничего страшного не произойдет, тем не менее некоторые callback-функции могут не сработать). Внутри callback-функции не допускаются блокировки в виде задержек или ожиданий. Дело в том, что callback-функции вызываются изнутри функции <a class="el" href="classmbee_with_callbacks.html#afbf5aad1ae37a39ecf904dc4cf3efb48" title="Wait for a API response of the given type, optionally filtered by the given match function...">waitFor()</a> или других дружественных функций, и если быстро не вернуться из callback, то в функции <a class="el" href="classmbee_with_callbacks.html#afbf5aad1ae37a39ecf904dc4cf3efb48" title="Wait for a API response of the given type, optionally filtered by the given match function...">waitFor()</a> может произойти таймаут. Отправка пакетов внутри callback-функции вполне допустима,однако вызов фукнций, связанных с приемом пакетов не допустим. К таким функциям относятся <a class="el" href="class_m_bee.html#af8382041415c32bc5c51a0a76e767aca" title="Чтение всех байт, имеющихся в приемном буфере UART. ">readPacket()</a> <a class="el" href="classmbee_with_callbacks.html#afbf5aad1ae37a39ecf904dc4cf3efb48" title="Wait for a API response of the given type, optionally filtered by the given match function...">waitFor()</a> и т.п. Вызов таких функций перепишет принятое сообщение, что заблокирует вызов callback-функций для всех ожидающих событий. </p>

<p class="definition">См. определение в файле <a class="el" href="_m_bee_8h_source.html">MBee.h</a> строка <a class="el" href="_m_bee_8h_source.html#l00186">186</a></p>
</div><h2 class="groupheader">Методы</h2>
<a id="a3ed2019f6ccc5412dc5876cfda8388a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed2019f6ccc5412dc5876cfda8388a8">&#9670;&nbsp;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mbeeWithCallbacks::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Главный цикл. </p>
<p>Этот метод должен регулярно вызываться для непрерывной обработки данных, поступающих от модуля <a class="el" href="class_m_bee.html" title="Основной интерфейс для связи с радиомодулями MBee всех серий. ">MBee</a> по последовательному интерфейсу и вызова соответствующих callback-функций. </p>

</div>
</div>
<a id="a821a5c46153ce7377aecef9a0e924b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821a5c46153ce7377aecef9a0e924b0d">&#9670;&nbsp;</a></span>onOtherResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mbeeWithCallbacks::onOtherResponse </td>
          <td>(</td>
          <td class="paramtype">void(*)(XBeeResponse &amp;, uintptr_t)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Регистрация callback-функции для события приема пакета от модуля. </p>
<p>Зарегистрированная функция будет вызываться всегда при любом успешном приеме пакета по UART если специфическая callback-функция для данного типа пакета не зарегистрирована. В качестве аргумента передается ссылка на принятый пакет. Данные, содержащиеся в принятом размещаются по указателю, переданному в качестве аргумента при регистрации данной callback-функции. </p>

<p class="definition">См. определение в файле <a class="el" href="_m_bee_8h_source.html">MBee.h</a> строка <a class="el" href="_m_bee_8h_source.html#l00224">224</a></p>

</div>
</div>
<a id="ae70f620ea276cdb9d815b3977910a3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70f620ea276cdb9d815b3977910a3dd">&#9670;&nbsp;</a></span>onPacketError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mbeeWithCallbacks::onPacketError </td>
          <td>(</td>
          <td class="paramtype">void(*)(uint8_t, uintptr_t)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Регистрация callback-функции для события ошибки чтения пакета. </p>
<p>Зарегистрированная функция будет вызываться каждый раз при возникновении ошибки разбора пакета, полученного от радиомодуля. Аргументом при вызове будет являться код ошибки, аналогичный получаемому при вызове <a class="el" href="class_m_bee_response.html#a9576bb06e8cc3ea30ab47cdfe06dc060" title="Возвращает код ошибки или 0, если их нет. ">MBeeResponse::getErrorCode()</a> и помещенный по указателю data, объявленному при регистрации callback-функции. </p>

<p class="definition">См. определение в файле <a class="el" href="_m_bee_8h_source.html">MBee.h</a> строка <a class="el" href="_m_bee_8h_source.html#l00197">197</a></p>

</div>
</div>
<a id="a36bc1e5f801d44f2af7d7d665d9884b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bc1e5f801d44f2af7d7d665d9884b2">&#9670;&nbsp;</a></span>onResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mbeeWithCallbacks::onResponse </td>
          <td>(</td>
          <td class="paramtype">void(*)(XBeeResponse &amp;, uintptr_t)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Регистрация callback-функции для события приема пакета от модуля. </p>
<p>Зарегистрированная функция будет вызываться всегда при любом успешном приеме пакета по UART перед тем, как будет вызвана специфическая для принятого пакета callback-функция или функция <a class="el" href="classmbee_with_callbacks.html#a821a5c46153ce7377aecef9a0e924b0d" title="Регистрация callback-функции для события приема пакета от модуля. ">onOtherResponse()</a>, если специфическая функция не зарегистрирована. В качестве аргумента передается ссылка на принятый пакет. Данные, содержащиеся в принятом размещаются по указателю, переданному в качестве аргумента при регистрации данной callback-функции. </p>

<p class="definition">См. определение в файле <a class="el" href="_m_bee_8h_source.html">MBee.h</a> строка <a class="el" href="_m_bee_8h_source.html#l00211">211</a></p>

</div>
</div>
<a id="ab2cf8239b2ab8eaff1fd1e1ea44533d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cf8239b2ab8eaff1fd1e1ea44533d2">&#9670;&nbsp;</a></span>sendAndWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mbeeWithCallbacks::sendAndWait </td>
          <td>(</td>
          <td class="paramtype">XBeeRequest &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a XBeeRequest (TX packet) out the serial port, and wait for a status response API frame (up until the given timeout). </p>
<p>Essentially this just calls <a class="el" href="class_m_bee.html#a2773c57b5447c92d19269b64557a63f6" title="Передача данных модулю или удаленному узлу. ">send()</a> and <a class="el" href="classmbee_with_callbacks.html#ac4d39cfc4baec25ff77b11c5a180859e" title="Wait for a status API response with the given frameId and return the status from the packet (for ZB_T...">waitForStatus()</a>. See waitForStatus for the meaning of the return value and more details. </p>

<p class="definition">См. определение в файле <a class="el" href="_m_bee_8h_source.html">MBee.h</a> строка <a class="el" href="_m_bee_8h_source.html#l00308">308</a></p>

</div>
</div>
<a id="afbf5aad1ae37a39ecf904dc4cf3efb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf5aad1ae37a39ecf904dc4cf3efb48">&#9670;&nbsp;</a></span>waitFor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Response &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mbeeWithCallbacks::waitFor </td>
          <td>(</td>
          <td class="paramtype">Response &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(Response &amp;, uintptr_t)&#160;</td>
          <td class="paramname"><em>func</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>frameId</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a API response of the given type, optionally filtered by the given match function. </p>
<p>If a match function is given it is called for every response of the right type received, passing the response and the data parameter passed to this method. If the function returns true (or if no function was passed), waiting stops and this method returns 0. If the function returns false, waiting continues. After the given timeout passes, this method returns XBEE_WAIT_TIMEOUT.</p>
<p>If a valid frameId is passed (e.g. 0-255 inclusive) and a status API response frame is received while waiting, that has a <em>non-zero</em> status, waiting stops and that status is received. This is intended for when a TX packet was sent and you are waiting for an RX reply, which will most likely never arrive when TX failed. However, since the status reply is not guaranteed to arrive before the RX reply (a remote module can send a reply before the ACK), first calling <a class="el" href="classmbee_with_callbacks.html#ac4d39cfc4baec25ff77b11c5a180859e" title="Wait for a status API response with the given frameId and return the status from the packet (for ZB_T...">waitForStatus()</a> and then <a class="el" href="classmbee_with_callbacks.html#afbf5aad1ae37a39ecf904dc4cf3efb48" title="Wait for a API response of the given type, optionally filtered by the given match function...">waitFor()</a> can sometimes miss the reply RX packet.</p>
<p>Note that when the intended response is received <em>before</em> the status reply, the latter will not be processed by this method and will be subsequently processed by e.g. <a class="el" href="classmbee_with_callbacks.html#a3ed2019f6ccc5412dc5876cfda8388a8" title="Главный цикл. ">loop()</a> normally.</p>
<p>While waiting, any other responses received are passed to the relevant callbacks, just as if calling <a class="el" href="classmbee_with_callbacks.html#a3ed2019f6ccc5412dc5876cfda8388a8" title="Главный цикл. ">loop()</a> continuously (except for the response sought, that one is only passed to the OnResponse handler and no others).</p>
<p>After this method returns, the response itself can still be retrieved using getResponse() as normal. </p>

<p class="definition">См. определение в файле <a class="el" href="_m_bee_8h_source.html">MBee.h</a> строка <a class="el" href="_m_bee_8h_source.html#l00296">296</a></p>

</div>
</div>
<a id="ac4d39cfc4baec25ff77b11c5a180859e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d39cfc4baec25ff77b11c5a180859e">&#9670;&nbsp;</a></span>waitForStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mbeeWithCallbacks::waitForStatus </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>frameId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a status API response with the given frameId and return the status from the packet (for ZB_TX_STATUS_RESPONSE, this returns just the delivery status, not the routing status). </p>
<p>If the timeout is reached before reading the response, XBEE_WAIT_TIMEOUT is returned instead.</p>
<p>While waiting, any other responses received are passed to the relevant callbacks, just as if calling <a class="el" href="classmbee_with_callbacks.html#a3ed2019f6ccc5412dc5876cfda8388a8" title="Главный цикл. ">loop()</a> continuously (except for the status response sought, that one is only passed to the OnResponse handler and no others).</p>
<p>After this method returns, the response itself can still be retrieved using getResponse() as normal. </p>

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li><a class="el" href="_m_bee_8h_source.html">MBee.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
